# exchange_config.py

exchange_settings = {
    'binance': {
        'enableRateLimit': True,
        'options': {
            'sandbox': True  # Enable sandbox mode
        }
    },
    'kucoin': {
        'enableRateLimit': True
    },
    # Add more exchanges as needed
}

# models.py
from django.db import models
from django.contrib.auth.models import User

class Exchange(models.Model):
    name = models.CharField(max_length=255)
    api_key = models.CharField(max_length=255)
    secret_key = models.CharField(max_length=255)
    user = models.ForeignKey(User, on_delete=models.CASCADE)

    def __str__(self):
        return f"{self.name} ({self.user.username})"


# exchange_config.py
import ccxt
from .models import Exchange

def get_exchange_objects(user):
    exchange_objects = {}
    exchanges = Exchange.objects.filter(user=user)

    for exchange in exchanges:
        config = exchange_settings.get(exchange.name, {})
        config.update({
            'apiKey': exchange.api_key,
            'secret': exchange.secret_key
        })
        exchange_objects[exchange.name] = getattr(ccxt, exchange.name)(config)

    return exchange_objects


# arbitrage.py
from .exchange_config import get_exchange_objects

def arbitrage(symbol, amount, exchanges, user):
    try:
        exchange_objects = get_exchange_objects(user)
        order_ids = []

        for exchange_name in exchanges:
            exchange = exchange_objects.get(exchange_name)
            if not exchange:
                print(f"Exchange '{exchange_name}' not found. Skipping.")
                continue

            # Fetch prices
            ticker = exchange.fetch_ticker(symbol)
            if not ticker:
                print(f"Failed to fetch ticker for {symbol} on {exchange_name}. Skipping.")
                continue

            bid_price = ticker['bid']
            ask_price = ticker['ask']

            # Calculate profit
            buy_total = bid_price * amount
            sell_total = ask_price * amount
            profit = sell_total - buy_total

            # Execute buy order
            buy_order = exchange.create_limit_buy_order(symbol, amount, bid_price)
            if not buy_order:
                print(f"Buy order on {exchange_name} failed. Skipping.")
                continue

            order_ids.append((exchange_name, buy_order['id']))

            print(f"Buy order placed on {exchange_name} successfully.")

        for exchange_name, order_id in order_ids:
            exchange = exchange_objects.get(exchange_name)
            if not exchange:
                continue

            # Check order status
            order_status = exchange.fetch_order(order_id, symbol=symbol)
            if not order_status or order_status['status'] != 'closed':
                print(f"Order on {exchange_name} not closed. Skipping sell order.")
                continue

            # Execute sell order
            sell_order = exchange.create_limit_sell_order(symbol, amount, ask_price)
            if not sell_order:
                print(f"Sell order on {exchange_name} failed. Skipping.")
                continue

            print(f"Sell order placed on {exchange_name} successfully.")

        print("Arbitrage successful!")
        return profit

    except Exception as e:
        print(f"Error during arbitrage: {e}")
        return 0

# views.py
from django.http import JsonResponse
from .arbitrage import arbitrage
from django.contrib.auth.decorators import login_required

@login_required
def arbitrage_view(request):
    symbol = "TRX/USDT"
    amount = 500.0

    user = request.user
    result = arbitrage(symbol, amount, exchanges=["binance", "kucoin", "kraken"], user=user)
    return JsonResponse({"result": result})

