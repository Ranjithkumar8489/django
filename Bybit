import ccxt
import threading
import time

# Constants
TRADING_FEES = 0.001  # 0.1% trading fee
INITIAL_AMOUNT_USDT = 1000  # Initial amount in USDT to trade with
MIN_PROFIT_THRESHOLD = 0.5  # Minimum profit to consider a trade worth executing

# Initialize Bybit through CCXT
exchange = ccxt.bybit({
    'enableRateLimit': True,
    'apiKey': 'YOUR_API_KEY',  # Replace with your actual API key
    'secret': 'YOUR_SECRET_KEY'  # Replace with your actual secret key
})

# Global variables to store pairs and prices
trading_pairs = []
triangular_pairs = []
prices = {}

# Fetch available trading pairs from Bybit using CCXT
def fetch_trading_pairs():
    global trading_pairs
    markets = exchange.load_markets()
    
    for symbol in markets:
        base = markets[symbol]['base']
        quote = markets[symbol]['quote']
        trading_pairs.append({'symbol': symbol, 'base': base, 'quote': quote})

# Find triangular arbitrage pairs dynamically
def find_triangular_pairs():
    global triangular_pairs
    assets = set()  # Collect all unique assets
    
    for pair in trading_pairs:
        assets.add(pair['base'])
        assets.add(pair['quote'])

    # Now generate the triangular arbitrage pairs
    for a in assets:
        for b in assets:
            if a == b:
                continue
            for c in assets:
                if a == c or b == c:
                    continue

                # Check if pairs (a/b, b/c, a/c) exist
                ab = f"{a}/{b}"
                bc = f"{b}/{c}"
                ac = f"{a}/{c}"
                
                if any(p['symbol'] == ab for p in trading_pairs) and \
                   any(p['symbol'] == bc for p in trading_pairs) and \
                   any(p['symbol'] == ac for p in trading_pairs):
                    triangular_pairs.append((ab, bc, ac))

    print(f"Found {len(triangular_pairs)} triangular pairs!")

# Fetch live price for a given symbol using CCXT
def fetch_price(symbol):
    ticker = exchange.fetch_ticker(symbol)
    return ticker['last']

# Function to calculate arbitrage opportunity
def calculate_arbitrage(ab, bc, ac):
    try:
        price_ab = fetch_price(ab)
        price_bc = fetch_price(bc)
        price_ac = fetch_price(ac)

        # Step 1: A -> B
        amount_b = INITIAL_AMOUNT_USDT / price_ab

        # Step 2: B -> C
        amount_c = amount_b / price_bc

        # Step 3: C -> A
        final_amount_usdt = amount_c * price_ac

        # Calculate profit
        profit = final_amount_usdt * (1 - TRADING_FEES)**3 - INITIAL_AMOUNT_USDT

        if profit > MIN_PROFIT_THRESHOLD:
            print(f"Arbitrage Opportunity Found! Profit: ${profit:.2f}")
            print(f"Pairs: {ab} -> {bc} -> {ac}")
            # Execute arbitrage trade
            execute_arbitrage(ab, bc, ac, amount_b)
        else:
            print(f"No arbitrage opportunity for {ab} -> {bc} -> {ac}. Profit: ${profit:.2f}")

    except Exception as e:
        print(f"Error calculating arbitrage: {e}")

# Execute trades to perform arbitrage
def execute_arbitrage(ab, bc, ac, amount_b):
    try:
        # Execute trade A -> B
        print(f"Executing: {ab}, Amount: {INITIAL_AMOUNT_USDT}")
        order_ab = exchange.create_market_buy_order(ab, INITIAL_AMOUNT_USDT)

        # Execute trade B -> C
        print(f"Executing: {bc}, Amount: {amount_b}")
        order_bc = exchange.create_market_buy_order(bc, amount_b)

        # Execute trade C -> A
        print(f"Executing: {ac}, Amount: {order_bc['filled']}")
        order_ac = exchange.create_market_sell_order(ac, order_bc['filled'])

        print("Arbitrage executed successfully!")
    except Exception as e:
        print(f"Error executing arbitrage: {e}")

# Continuously monitor prices and check for arbitrage
def monitor_arbitrage():
    while True:
        for ab, bc, ac in triangular_pairs:
            calculate_arbitrage(ab, bc, ac)
        time.sleep(1)  # Small delay to avoid rate-limiting issues

# Main program
if __name__ == "__main__":
    # Step 1: Fetch trading pairs
    fetch_trading_pairs()

    # Step 2: Find triangular pairs
    find_triangular_pairs()

    # Step 3: Start monitoring for arbitrage opportunities
    monitor_thread = threading.Thread(target=monitor_arbitrage)
    monitor_thread.start()
