import ccxt
import time
from itertools import permutations

# Initialize exchange
exchange = ccxt.binance({
    'apiKey': 'YOUR_API_KEY',
    'secret': 'YOUR_SECRET_KEY',
})

MIN_PROFIT_THRESHOLD = 0.2
BASE_AMOUNT = 1.0

def get_available_pairs():
    markets = exchange.load_markets()
    return list(markets.keys())

def find_triangular_pairs():
    pairs = get_available_pairs()
    triangular_pairs = []
    symbols = set()

    for pair in pairs:
        base, quote = pair.split('/')
        symbols.add(base)
        symbols.add(quote)

    for combo in permutations(symbols, 3):
        a, b, c = combo
        pair1 = f'{a}/{b}'
        pair2 = f'{b}/{c}'
        pair3 = f'{c}/{a}'

        if pair1 in pairs and pair2 in pairs and pair3 in pairs:
            triangular_pairs.append((pair1, pair2, pair3))

    return triangular_pairs

def fetch_order_book(pair, required_volume):
    try:
        order_book = exchange.fetch_order_book(pair)
        return {
            'bids': [bid for bid in order_book['bids'] if bid[1] >= required_volume],
            'asks': [ask for ask in order_book['asks'] if ask[1] >= required_volume]
        }
    except Exception as e:
        print(f"Error fetching order book for {pair}: {str(e)}")
        return None

def get_best_price(order_book, direction, amount_needed):
    total_volume = 0
    total_cost = 0
    orders = order_book['asks'] if direction == 'buy' else order_book['bids']
    
    for price, volume in orders:
        if total_volume + volume >= amount_needed:
            total_cost += (amount_needed - total_volume) * price
            total_volume = amount_needed
            break
        total_cost += volume * price
        total_volume += volume

    if total_volume < amount_needed:
        return None

    return total_cost / total_volume

def execute_trade(pair, direction, amount):
    try:
        if direction == 'buy':
            exchange.create_market_buy_order(pair, amount)
        elif direction == 'sell':
            exchange.create_market_sell_order(pair, amount)
        print(f"Executed {direction} order: {pair} | Amount: {amount}")
    except Exception as e:
        print(f"Error executing trade {direction} {pair}: {str(e)}")

def advanced_calculate_arbitrage(pair1, pair2, pair3, base_amount):
    try:
        book1 = fetch_order_book(pair1, base_amount)
        book2 = fetch_order_book(pair2, base_amount)
        book3 = fetch_order_book(pair3, base_amount)

        if not (book1 and book2 and book3):
            return None

        trade_strategies = [
            {"trade1": "buy", "trade2": "buy", "trade3": "sell"},
            {"trade1": "buy", "trade2": "sell", "trade3": "sell"},
            {"trade1": "sell", "trade2": "sell", "trade3": "buy"},
            {"trade1": "sell", "trade2": "buy", "trade3": "buy"},
            {"trade1": "sell", "trade2": "buy", "trade3": "sell"},
            {"trade1": "buy", "trade2": "sell", "trade3": "buy"},
        ]

        def execute_trade_strategy(strategy, starting_amount):
            amount = starting_amount
            trade_details = []

            for pair, direction in zip([pair1, pair2, pair3], [strategy['trade1'], strategy['trade2'], strategy['trade3']]):
                price = None
                if direction == "buy":
                    price = get_best_price(fetch_order_book(pair, amount), "buy", amount)
                    if price is None:
                        return None, None
                    amount_received = amount / price
                    trade_details.append({"pair": pair, "action": "buy", "price": price, "amount_spent": amount, "amount_received": amount_received})
                    execute_trade(pair, "buy", amount)
                    amount = amount_received
                elif direction == "sell":
                    price = get_best_price(fetch_order_book(pair, amount), "sell", amount)
                    if price is None:
                        return None, None
                    amount_received = amount * price
                    trade_details.append({"pair": pair, "action": "sell", "price": price, "amount_spent": amount, "amount_received": amount_received})
                    execute_trade(pair, "sell", amount)
                    amount = amount_received

            return amount, trade_details

        best_trade_plan = None
        best_profit_percentage = -float("inf")
        best_roi = -float("inf")

        for strategy in trade_strategies:
            final_amount, trade_plan = execute_trade_strategy(strategy, base_amount)

            if final_amount is None or trade_plan is None:
                continue

            profit_percentage = (final_amount - base_amount) / base_amount * 100
            roi = (final_amount - base_amount) / base_amount * 100

            if profit_percentage > best_profit_percentage:
                best_profit_percentage = profit_percentage
                best_roi = roi
                best_trade_plan = trade_plan

        if best_profit_percentage > MIN_PROFIT_THRESHOLD:
            return {"profit_percentage": best_profit_percentage, "roi": best_roi, "trade_plan": best_trade_plan}

        return None

    except Exception as e:
        print(f"Error calculating arbitrage for {pair1}, {pair2}, {pair3}: {str(e)}")
        return None

def find_arbitrage_opportunities():
    triangular_pairs = find_triangular_pairs()
    print(f"Found {len(triangular_pairs)} triangular pairs to check.")
    
    for pair1, pair2, pair3 in triangular_pairs:
        result = advanced_calculate_arbitrage(pair1, pair2, pair3, BASE_AMOUNT)

        if result:
            print(f"Arbitrage Opportunity Found: {pair1} -> {pair2} -> {pair3}")
            print(f"Profit: {result['profit_percentage']:.2f}%")
            print(f"ROI: {result['roi']:.2f}%")
            for trade in result['trade_plan']:
                print(f"Trade: {trade['action']} {trade['pair']} at price {trade['price']} | Amount Spent: {trade['amount_spent']} | Amount Received: {trade['amount_received']}")
        else:
            print(f"No arbitrage opportunity for {pair1}, {pair2}, {pair3}")

def main():
    while True:
        find_arbitrage_opportunities()
        time.sleep(10)

if __name__ == "__main__":
    main()
